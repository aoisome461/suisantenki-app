import streamlit as st
import requests
import pandas as pd
from datetime import datetime, timedelta
import numpy as np
import streamlit.components.v1 as components

# 1. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æ‹ ç‚¹ (13ç®‡æ‰€)
LOCATIONS = {
    "å‡½é¤¨": {"lat": 41.76, "lon": 140.74, "type": "marine"},
    "çŸ³å·»": {"lat": 38.41, "lon": 141.32, "type": "marine"},
    "ç¦å³¶ç›¸é¦¬": {"lat": 37.83, "lon": 140.95, "type": "marine"},
    "åƒè‘‰å‹æµ¦": {"lat": 35.15, "lon": 140.32, "type": "marine"},
    "å¯Œå±±é­šæ´¥": {"lat": 36.83, "lon": 137.40, "type": "marine"},
    "æ„›çŸ¥è’²éƒ¡": {"lat": 34.82, "lon": 137.22, "type": "marine"},
    "äº¬éƒ½èˆé¶´": {"lat": 35.60, "lon": 135.30, "type": "marine"},
    "é¦™å·å¤šåº¦æ´¥": {"lat": 34.27, "lon": 133.75, "type": "marine"},
    "å¾³å³¶": {"lat": 34.00, "lon": 134.70, "type": "marine"},
    "ç¦å²¡åšå¤š": {"lat": 33.60, "lon": 130.40, "type": "marine"},
    "æ±äº¬æ¸¯": {"lat": 35.689488, "lon": 139.691706, "type": "marine"},
    "å…µåº«é¦™ä½": {"lat": 35.64, "lon": 134.63, "type": "marine"}, # è¿½åŠ æ‹ ç‚¹
    "åŒ—æµ·é“åˆ¥æµ·": {"lat": 43.39, "lon": 145.12, "type": "marine"}, # è¿½åŠ æ‹ ç‚¹
    "æ±äº¬": {"lat": 35.66, "lon": 139.79, "type": "weather"},
}

# API Call Functions
def get_marine_data(lat, lon, days=3):
    """Fetch marine data (wave_height, wind_speed) from Open-Meteo Marine API."""
    end_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
    url = f"https://marine-api.open-meteo.com/v1/marine?latitude={lat}&longitude={lon}&hourly=wave_height,wind_speed_10m&forecast_days={days}&timezone=Asia%2FTokyo"
    try:
        response = requests.get(url)
        response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
        return response.json()
    except requests.exceptions.HTTPError as e:
        st.error(f"æµ·æ´‹APIã§ã®HTTPã‚¨ãƒ©ãƒ¼: {e} (Status: {e.response.status_code})")
        return None
    except requests.exceptions.ConnectionError as e:
        st.error(f"æµ·æ´‹APIã¸ã®æ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
        return None
    except requests.exceptions.Timeout as e:
        st.error(f"æµ·æ´‹APIã¸ã®æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {e}")
        return None
    except requests.exceptions.RequestException as e:
        st.error(f"æµ·æ´‹APIã§ã®äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: {e}")
        return None

def get_weather_data(lat, lon, days=4): # Changed to 4 days to get yesterday's data relative to today
    """Fetch weather data (temperature, precipitation, wind_speed, and daily aggregates) from Open-Meteo Forecast API."""
    end_date = (datetime.now() + timedelta(days=days-1)).strftime('%Y-%m-%d') # Adjust end_date to reflect forecast_days
    url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&hourly=temperature_2m,precipitation,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,precipitation_probability_max&forecast_days={days}&timezone=Asia%2FTokyo&wind_speed_unit=ms"
    try:
        response = requests.get(url)
        response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
        return response.json()
    except requests.exceptions.HTTPError as e:
        st.error(f"å¤©æ°—APIã§ã®HTTPã‚¨ãƒ©ãƒ¼: {e} (Status: {e.response.status_code})")
        return None
    except requests.exceptions.ConnectionError as e:
        st.error(f"å¤©æ°—APIã¸ã®æ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
        return None
    except requests.exceptions.Timeout as e:
        st.error(f"å¤©æ°—APIã¸ã®æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {e}")
        return None
    except requests.exceptions.RequestException as e:
        st.error(f"å¤©æ°—APIã§ã®äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼: {e}")
        return None

def get_wave_status(wave_height):
    """Determine wave status and color based on wave height."""
    if wave_height >= 2.5:
        return "æ™‚åŒ–", "red"
    elif wave_height >= 1.5:
        return "æ³¨æ„", "orange"
    else:
        return "å‡ª", "blue"

def calculate_moon_age(date):
    """
    Calculate the approximate moon age for a given date.
    Source: https://mementomori.me/a/2012/05/26/javascript-moon-phase/
    """
    gregorian_date_str = date.strftime('%Y/%m/%d')
    
    # Constants for calculation
    Y = int(gregorian_date_str.split('/')[0])
    M = int(gregorian_date_str.split('/')[1])
    D = int(gregorian_date_str.split('/')[2])

    if M < 3:
        Y -= 1
        M += 12

    moon_age = (Y * 365 + Y // 4 - Y // 100 + Y // 400 + M * 30 + (M * 3 + 6) // 5 + D - 694039) % 29.530588

    return moon_age

def is_spring_tide(date):
    """
    Determine if the given date is a spring tide (å¤§æ½®).
    This is a more accurate model based on astronomical approximation.
    Source: https://mementomori.me/a/2012/05/26/javascript-moon-phase/ (Japanese reference for lunar phase calculation)
    Adapted to Python.
    """
    # Number of days from 2000-01-06 (new moon) to the target date
    diff = date - datetime(2000, 1, 6).date()
    days_since_new_moon_ref = diff.days

    # Synodic month (period from one new moon to the next)
    SYNODIC_MONTH = 29.530588

    # Current lunar phase in days from new moon
    current_lunar_day = days_since_new_moon_ref % SYNODIC_MONTH

    # Spring tides occur around New Moon (0 days) and Full Moon (SYNODIC_MONTH / 2)
    # We consider +/- 3 days around these points as spring tide
    if (0 <= current_lunar_day <= 3) or \
       (SYNODIC_MONTH - 3 <= current_lunar_day < SYNODIC_MONTH) or \
       (SYNODIC_MONTH/2 - 3 <= current_lunar_day <= SYNODIC_MONTH/2 + 3):
        return "å¤§æ½®"
    return "å°æ½®ãƒ»ä¸­æ½®"
    
def get_tokyo_demand_prediction(tokyo_weather_data):
    """
    Generate demand prediction text for Tokyo based on temperature and precipitation probability.
    Criteria:
    - Temperature -3C or less than previous day, OR
    - Precipitation probability >= 50%
    Result: "æ¥åº—ãƒªã‚¹ã‚¯ã‚ã‚Š/é‹éœ€è¦å¢—"
    """
    if not tokyo_weather_data or 'daily' not in tokyo_weather_data:
        return "æ±äº¬ã®éœ€è¦äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

    daily_data = tokyo_weather_data['daily']
    
    # Dates are in ISO 8601 format (e.g., "2023-10-27")
    today_str = datetime.now().strftime('%Y-%m-%d')
    yesterday_str = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')

    # Find today's and yesterday's data
    today_index = -1
    yesterday_index = -1
    for i, date_str in enumerate(daily_data['time']):
        if date_str == today_str:
            today_index = i
        if date_str == yesterday_str:
            yesterday_index = i

    recommendation = []

    # 1. Temperature difference
    if today_index != -1 and yesterday_index != -1:
        temp_today_max = daily_data['temperature_2m_max'][today_index]
        temp_yesterday_max = daily_data['temperature_2m_max'][yesterday_index]
        if temp_today_max - temp_yesterday_max <= -3:
            recommendation.append("æ°—æ¸©ãŒå‰æ—¥æ¯”-3â„ƒä»¥ä¸‹")

    # 2. Precipitation probability
    if today_index != -1:
        precip_prob_today = daily_data['precipitation_probability_max'][today_index]
        if precip_prob_today >= 50:
            recommendation.append(f"é™æ°´ç¢ºç‡{precip_prob_today}%ä»¥ä¸Š")

    if recommendation:
        return "æ¥åº—ãƒªã‚¹ã‚¯ã‚ã‚Š/é‹éœ€è¦å¢— ({})".format("ã€".join(recommendation))
    return "ç‰¹ã«ãªã—"    

# Streamlit UI

st.set_page_config(layout="wide")
st.title("ğŸŒŠ UMI-MIRU: æ°´ç”£ãŠå¤©æ°—ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ ğŸŸ")

# æœ€ä¸Šéƒ¨: æœ€æ–°å¤©æ°—å›³
st.subheader("ç¾åœ¨ã®å¤©æ°—å›³")
st.image("https://www.jma.go.jp/bosai/numericmap/data/nwpmap/asjp.png", caption='æ°—è±¡åºï¼šå®Ÿæ³å¤©æ°—å›³', use_container_width=True)


# Sidebar
st.sidebar.header("è¨­å®š")
selected_location_options = [loc for loc in LOCATIONS.keys() if LOCATIONS[loc]["type"] == "marine"]
try:
    default_index = selected_location_options.index("åƒè‘‰å‹æµ¦")
except ValueError:
    default_index = 0 # Fallback to the first item if "åƒè‘‰å‹æµ¦" is not found

selected_location = st.sidebar.selectbox("æ‹ ç‚¹ã‚’é¸æŠ", selected_location_options, index=default_index)
refresh_button = st.sidebar.button("ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°")

# Main Area
col1, col2 = st.columns([2, 1]) # Adjust column ratios as needed

with col1:
    st.header("ç”£åœ°æƒ…å ±")
    st.subheader("ç”£åœ°åˆ¥ãƒ»æµ·æ³ãƒãƒˆãƒªãƒƒã‚¯ã‚¹")

    # Create a DataFrame to hold marine data for the matrix
    marine_matrix_data = []
    marine_locations = {name: data for name, data in LOCATIONS.items() if data["type"] == "marine"}

    dates = [(datetime.now() + timedelta(days=i)).date() for i in range(3)]
    date_cols = [date.strftime('%m/%d') for date in dates]

    for loc_name, loc_data in marine_locations.items():
        marine_data = get_marine_data(loc_data["lat"], loc_data["lon"])

        if marine_data and 'hourly' in marine_data:
            row_data = {"æ‹ ç‚¹": loc_name}
            for i, date in enumerate(dates):
                # Get average wave height for the day
                # Assuming hourly data starts from today 00:00.
                # Find indices for the current day
                current_day_hourly_indices = [
                    j for j, time_str in enumerate(marine_data['hourly']['time'])
                    if datetime.fromisoformat(time_str).date() == date
                ]
                
                daily_wave_heights = [
                    marine_data['hourly']['wave_height'][j] for j in current_day_hourly_indices
                    if marine_data['hourly']['wave_height'][j] is not None
                ]
                
                if daily_wave_heights:
                    avg_wave_height = np.mean(daily_wave_heights)
                    status, color = get_wave_status(avg_wave_height)
                    spring_tide_status = is_spring_tide(date)
                    moon_age_today = calculate_moon_age(date) # æœˆé½¢è¨ˆç®—
                    row_data[date_cols[i]] = f":{color}[{status} ({avg_wave_height:.1f}m)] ({spring_tide_status}, æœˆé½¢: {moon_age_today:.1f})"
                else:
                    row_data[date_cols[i]] = "ãƒ‡ãƒ¼ã‚¿ãªã—"
            marine_matrix_data.append(row_data)
        else:
            row_data = {"æ‹ ç‚¹": loc_name}
            for date_col in date_cols:
                row_data[date_col] = "APIã‚¨ãƒ©ãƒ¼"
            marine_matrix_data.append(row_data)

    marine_df = pd.DataFrame(marine_matrix_data)
    if not marine_df.empty:
        marine_df.set_index("æ‹ ç‚¹", inplace=True)
    st.table(marine_df)

    # è©³ç´°ã‚°ãƒ©ãƒ• (Selected Location Detailed Graphs)
    st.subheader(f"{selected_location} ã®è©³ç´°ã‚°ãƒ©ãƒ•")
    selected_loc_data = LOCATIONS[selected_location]
    selected_marine_data = get_marine_data(selected_loc_data["lat"], selected_loc_data["lon"], days=3)

    if selected_marine_data and 'hourly' in selected_marine_data:
        hourly_data = pd.DataFrame({
            'time': pd.to_datetime(selected_marine_data['hourly']['time']),
            'wave_height': selected_marine_data['hourly']['wave_height'],
            'wind_speed_10m': selected_marine_data['hourly']['wind_speed_10m']
        })
        hourly_data.set_index('time', inplace=True)

        # Filter for the next 3 days (assuming 'days=3' in get_marine_data already provides this)
        # However, to be explicit, let's ensure we only take the relevant forecast period
        forecast_end_time = datetime.now() + timedelta(days=3)
        hourly_data = hourly_data[hourly_data.index <= forecast_end_time]


        st.line_chart(hourly_data['wave_height'].rename("æ³¢ã®é«˜ã•(m)"))
        st.line_chart(hourly_data['wind_speed_10m'].rename("é¢¨é€Ÿ(m/s)"))
    else:
        st.warning(f"{selected_location} ã®è©³ç´°ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")

with col2:
    st.header("æ±äº¬ãƒãƒ¼ã‚±ãƒƒãƒˆ")
    tokyo_location = LOCATIONS["æ±äº¬"]
    tokyo_weather_data = get_weather_data(tokyo_location["lat"], tokyo_location["lon"])

    if tokyo_weather_data:
        st.subheader("éœ€è¦äºˆæ¸¬")
        demand_prediction_text = get_tokyo_demand_prediction(tokyo_weather_data)
        st.info(demand_prediction_text)

        st.subheader("æ±äº¬ã®å¤©æ°—")
        daily_tokyo_weather = pd.DataFrame(tokyo_weather_data['daily'])
        daily_tokyo_weather['time'] = pd.to_datetime(daily_tokyo_weather['time']).dt.strftime('%m/%d')
        daily_tokyo_weather.set_index('time', inplace=True)
        st.dataframe(daily_tokyo_weather[['temperature_2m_max', 'temperature_2m_min', 'precipitation_sum', 'precipitation_probability_max']].head(3).rename(columns={
            'temperature_2m_max': 'æœ€é«˜æ°—æ¸©(â„ƒ)',
            'temperature_2m_min': 'æœ€ä½æ°—æ¸©(â„ƒ)',
            'precipitation_sum': 'é™æ°´é‡(mm)',
            'precipitation_probability_max': 'é™æ°´ç¢ºç‡(%)'
        }))

        # Add advice if minimum temperature is below 5 degrees for today
        if not daily_tokyo_weather.empty:
            today_min_temp = daily_tokyo_weather.iloc[0]['temperature_2m_min']
            if today_min_temp < 5:
                st.warning("å†·ãˆè¾¼ã¿æ³¨æ„ï¼šæ¸©ã‹ã„ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ææ¡ˆã‚’å¼·åŒ–")

        hourly_tokyo_wind = pd.DataFrame(tokyo_weather_data['hourly'])
        hourly_tokyo_wind['time'] = pd.to_datetime(hourly_tokyo_wind['time'])
        st.dataframe(hourly_tokyo_wind[['time', 'wind_speed_10m']].rename(columns={
            'time': 'æ™‚é–“',
            'wind_speed_10m': 'é¢¨é€Ÿ(m/s)'
        }).head(24)) # Displaying only the first 24 hours for brevity


        # Wind speed advice logic
        wind_advice_messages = []
        forecast_days_count = len(tokyo_weather_data['daily']['time'])
        
        for i in range(forecast_days_count):
            current_date_str = tokyo_weather_data['daily']['time'][i]
            current_date = datetime.fromisoformat(current_date_str).date()
            
            # Filter hourly data for the current day
            daily_hourly_wind = hourly_tokyo_wind[hourly_tokyo_wind['time'].dt.date == current_date]
            
            if not daily_hourly_wind.empty:
                max_wind_speed_day = daily_hourly_wind['wind_speed_10m'].max()
                
                # For >= 3m/s, show specific time ranges
                if max_wind_speed_day >= 3:
                    wind_3m_times = daily_hourly_wind[daily_hourly_wind['wind_speed_10m'] >= 3]['time'].dt.strftime('%H:%M').tolist()
                    if wind_3m_times:
                        time_ranges = []
                        if len(wind_3m_times) > 1:
                            start_time = None
                            end_time = None
                            for k in range(len(wind_3m_times)):
                                current_hour = int(wind_3m_times[k].split(':')[0])
                                if start_time is None:
                                    start_time = current_hour
                                    end_time = current_hour
                                elif current_hour == end_time + 1:
                                    end_time = current_hour
                                else:
                                    time_ranges.append(f"{start_time:02d}:00-{end_time:02d}:00")
                                    start_time = current_hour
                                    end_time = current_hour
                            time_ranges.append(f"{start_time:02d}:00-{end_time:02d}:00")
                        else:
                            time_ranges.append(f"{int(wind_3m_times[0].split(':')[0]):02d}:00")

                        time_range_str = ", ".join(time_ranges)
                        wind_advice_messages.append(f"â€¢ {current_date.strftime('%m/%d')} : è»½ã„ã‚‚ã®ãŒé£›ã¶å¯èƒ½æ€§ã‚ã‚Š ({time_range_str}é ƒ)")
                        
                # For >= 5m/s and >= 10m/s, add general warnings for the day
                if max_wind_speed_day >= 10:
                    wind_advice_messages.append(f"â€¢ {current_date.strftime('%m/%d')} : å¼·é¢¨æ³¨æ„å ±ã®å¯èƒ½æ€§ã‚ã‚Š")
                elif max_wind_speed_day >= 5:
                    wind_advice_messages.append(f"â€¢ {current_date.strftime('%m/%d')} : å¼·é¢¨æ³¨æ„")

        if wind_advice_messages:
            st.warning("  \n".join(wind_advice_messages))
    else:
        st.warning("æ±äº¬ã®å¤©æ°—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
    
# [ä¸‹æ®µ] Windyã¨ç”»åƒã€ãƒªãƒ³ã‚¯
st.subheader("Windy.com (é¢¨ã¨æ³¢)")
components.html(
    """
    <iframe
        width="100%"
        height="600px"
        src="https://embed.windy.com/embed2.html?lat=35.6895&lon=139.6917&zoom=6&overlay=waves&product=ecmwf&level=surface&menu=&message=&marker=&calendar=now&pressure=&type=map&location=coordinates&detail=&metricWind=default&metricTemp=default&radarRange=-1"
        frameborder="0"
    ></iframe>
    """,
    height=600,
)

st.subheader("æµ·é¢æ°´æ¸©å›³")
st.image("https://www.data.jma.go.jp/gmd/kaikyou/kaikyou/tile/jp/png/sst_now.png", caption='æ°—è±¡åºï¼šæ—¥åˆ¥æµ·é¢æ°´æ¸©ï¼ˆæ—¥æœ¬è¿‘æµ·ï¼‰', use_container_width=True)

st.subheader("å…¨å›½æ³¢æµªå®Ÿæ³å›³")
st.image("https://www.data.jma.go.jp/gmd/waveinf/tile/jp/png/p_now.png", caption='æ°—è±¡åºï¼šå…¨å›½æ³¢æµªå®Ÿæ³å›³', use_container_width=True)

st.markdown("---")
st.subheader("æ°—è±¡åºæä¾›æƒ…å ±ã¸ã®ãƒªãƒ³ã‚¯")
st.link_button("æµ·é¢æ°´æ¸© è©³ç´°ãƒšãƒ¼ã‚¸", "https://www.data.jma.go.jp/kaikyou/kaikyou/tile/jp/index_sstanl.html")
st.link_button("æ°—è±¡åº å…¬å¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼", "https://www.jma.go.jp/jma/menu/menuflash.html")